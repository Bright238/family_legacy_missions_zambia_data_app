'use client';

import Papa from 'papaparse';
import { varAlpha } from 'minimal-shared/utils';
import { useState, useEffect, useCallback } from 'react';
import { useBoolean, useSetState } from 'minimal-shared/hooks';

import Tab from '@mui/material/Tab';
import Box from '@mui/material/Box';
import Tabs from '@mui/material/Tabs';
import Card from '@mui/material/Card';
import Table from '@mui/material/Table';
import Button from '@mui/material/Button';
import Tooltip from '@mui/material/Tooltip';
import TableBody from '@mui/material/TableBody';
import IconButton from '@mui/material/IconButton';
import CircularProgress from '@mui/material/CircularProgress';

import { paths } from 'src/routes/paths';

import { fIsAfter, fIsBetween } from 'src/utils/format-time';

import { DashboardContent } from 'src/layouts/dashboard';
import axiosInstance, { fetcher, endpoints } from 'src/lib/axios';

import { Label } from 'src/components/label';
import { toast } from 'src/components/snackbar';
import { Iconify } from 'src/components/iconify';
import { Scrollbar } from 'src/components/scrollbar';
import { ConfirmDialog } from 'src/components/custom-dialog';
import { CustomBreadcrumbs } from 'src/components/custom-breadcrumbs';
import {
  useTable,
  emptyRows,
  rowInPage,
  TableNoData,
  getComparator,
  TableSkeleton,
  TableEmptyRows,
  TableHeadCustom,
  TableSelectedAction,
  TablePaginationCustom,
} from 'src/components/table';

import { OrderTableRow } from '../order-table-row';
import { JobFiltersResult } from '../job-filters-result';
import { OrderTableToolbar } from '../order-table-toolbar';

// ----------------------------------------------------------------------

const STATUS_OPTIONS = [
  { value: 'all', label: 'All' },
  { value: 'active', label: 'Active' },
  { value: 'discharged', label: 'Discharged' },
];

const TABLE_HEAD = [
  { id: 'childFirstName', label: 'Child First Name' },
  { id: 'childLastName', label: 'Child Last Name' },
  { id: 'date', label: 'Assessment Date', width: 120 },
  { id: 'employeeName', label: 'Assessor Name', width: 150 },
  { id: 'childGender', label: 'Child Gender', width: 100 },
  { id: 'school', label: 'School', width: 150 },
  { id: 'ovcStatus', label: 'OVC Status', width: 200 },
  { id: 'programStatus', label: 'Program Status', width: 110 },
  { id: '', width: 88 },
];

// Column mapping function for CSV import
const mapColumnToField = (csvHeader) => {
  const normalizedHeader = csvHeader
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s_]/g, '')
    .replace(/\s+/g, '_');

  const fieldVariations = {
    childFirstName: ['child_first_name', 'child_firstname', 'child_first name', 'child_name'],
    childLastName: ['child_last_name', 'child_lastname', 'child_last name', 'child_surname'],
    date: ['date', 'assessment_date', 'assess_date'],
    employeeName: ['employee_name', 'assessor_name', 'staff_name', 'evaluator_name'],
    childGender: ['child_gender', 'gender', 'child_sex'],
    school: ['school', 'school_name', 'institution'],
    ovcStatus: ['ovc_status', 'vulnerability_status', 'child_status'],
    programStatus: ['program_status', 'status', 'enrollment_status'],
    childAge: ['child_age', 'age', 'child_years'],
    region: ['region', 'area', 'location'],
    schoolCategory: ['school_category', 'school_type'],
    grade: ['grade', 'class_level'],
    catchmentArea: ['catchment_area', 'catchment', 'area'],
    specificResidence: ['specific_residence', 'residence', 'address'],
    hasBirthRecord: ['has_birth_record', 'birth_record', 'birth_certificate'],
    guardianFirstName: ['guardian_first_name', 'guardian_firstname', 'guardian_name'],
    guardianLastName: ['guardian_last_name', 'guardian_lastname', 'guardian_surname'],
    guardianContact: ['guardian_contact', 'guardian_phone', 'contact_number'],
  };

  for (const [field, variations] of Object.entries(fieldVariations)) {
    if (variations.includes(normalizedHeader)) {
      return field;
    }
  }

  return null;
};

// ----------------------------------------------------------------------

export function JobListView() {
  const table = useTable({ defaultOrderBy: 'childFirstName' });

  const confirmDialog = useBoolean();

  const [tableData, setTableData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [importLoading, setImportLoading] = useState(false);

  const filters = useSetState({
    name: '',
    status: 'all',
    startDate: null,
    endDate: null,
  });
  const { state: currentFilters, setState: updateFilters } = filters;

  const dateError = fIsAfter(currentFilters.startDate, currentFilters.endDate);

  const fetchVulnerability = useCallback(async () => {
    try {
      setLoading(true);
      const response = await fetcher(endpoints.vulnerability_assessments.list);
      console.log('Fetched vulnerability_assessments (Raw Response):', response);
      setTableData(response.data.data || []);
    } catch (error) {
      toast.error('Failed to fetch vulnerability assessments');
      console.error('Error fetching vulnerability:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchVulnerability();
  }, [fetchVulnerability]);

  const handleImport = useCallback(
    (file) => {
      setImportLoading(true);
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: async (result) => {
          console.log('Imported CSV Data (Raw):', result.data);

          const csvHeaders = result.meta.fields || [];
          console.log('Detected CSV Headers (Raw):', csvHeaders);

          if (!csvHeaders.length) {
            console.error('No headers detected in CSV. Please ensure the CSV has headers.');
            toast.error('Invalid CSV format: No headers detected.');
            setImportLoading(false);
            return;
          }

          const headerMapping = {};
          csvHeaders.forEach((header) => {
            const mappedField = mapColumnToField(header);
            if (mappedField) {
              headerMapping[header] = mappedField;
            }
          });
          console.log('Header Mapping:', headerMapping);

          const requiredFields = ['childFirstName', 'childLastName', 'date', 'employeeName'];
          const missingFields = requiredFields.filter(
            (field) => !Object.values(headerMapping).includes(field)
          );
          if (missingFields.length > 0) {
            console.error('Required fields missing in mapping:', missingFields);
            toast.error(`CSV must include columns: ${missingFields.join(', ')}.`);
            setImportLoading(false);
            return;
          }

          if (!result.data.length) {
            console.error('No data rows found in CSV.');
            toast.error('No data to import: CSV is empty.');
            setImportLoading(false);
            return;
          }

          const mappedData = result.data.map((row, index) => {
            const mappedRow = {};
            TABLE_HEAD.forEach((head) => {
              if (head.id) {
                mappedRow[head.id] = '';
              }
            });

            Object.keys(row).forEach((csvHeader) => {
              const field = headerMapping[csvHeader];
              if (field) {
                mappedRow[field] = row[csvHeader] || '';
              }
            });

            console.log(`Row ${index + 1} After Mapping:`, mappedRow);
            return mappedRow;
          });

          const validData = mappedData.filter((item) => {
            if (!item.childFirstName || !item.childLastName || !item.date || !item.employeeName) {
              console.warn('Skipping row due to missing required fields:', item);
              return false;
            }
            if (
              item.programStatus &&
              !['active', 'discharged'].includes(item.programStatus.toLowerCase())
            ) {
              console.warn('Invalid program status, setting to default "active":', item.programStatus);
              item.programStatus = 'active';
            } else if (!item.programStatus) {
              item.programStatus = 'active';
            }
            return true;
          });

          if (validData.length === 0) {
            console.error('No valid data after validation. All rows were skipped.');
            toast.error('No valid data to import. Ensure required fields are provided.');
            setImportLoading(false);
            return;
          }

          try {
            if (!endpoints.vulnerability_assessments?.create) {
              console.error('Vulnerability assessments create endpoint is undefined:', endpoints);
              toast.error('Configuration error: Missing vulnerability assessments create endpoint.');
              setImportLoading(false);
              return;
            }

            const importPromises = validData.map((item) =>
              axiosInstance.post(endpoints.vulnerability_assessments.create, item)
            );
            await Promise.all(importPromises);
            toast.success(`Successfully imported ${validData.length} vulnerability assessments`);
            await fetchVulnerability();
          } catch (error) {
            console.error('Failed to import data:', error);
            toast.error('Failed to import data: ' + (error.message || 'Unknown error'));
          } finally {
            setImportLoading(false);
          }
        },
        error: (error) => {
          console.error('Error parsing CSV:', error);
          toast.error('Failed to parse CSV file');
          setImportLoading(false);
        },
      });
    },
    [fetchVulnerability]
  );

  const dataFiltered = applyFilter({
    inputData: tableData,
    comparator: getComparator(table.order, table.orderBy),
    filters: currentFilters,
    dateError,
  });

  const dataInPage = rowInPage(dataFiltered, table.page, table.rowsPerPage);

  const canReset =
    !!currentFilters.name ||
    currentFilters.status !== 'all' ||
    (!!currentFilters.startDate && !!currentFilters.endDate);

  const notFound = (!dataFiltered.length && canReset) || !dataFiltered.length;

  const handleDeleteRow = useCallback(
    async (id) => {
      try {
        if (!endpoints.vulnerability_assessments?.delete) {
          console.error('Vulnerability assessments delete endpoint is undefined:', endpoints);
          toast.error('Configuration error: Missing vulnerability assessments delete endpoint.');
          return;
        }
        await axiosInstance.delete(`${endpoints.vulnerability_assessments.delete}/${id}`);
        await fetchVulnerability();
        toast.success('Delete success!');
        table.onUpdatePageDeleteRow(dataInPage.length);
      } catch (error) {
        toast.error('Failed to delete');
        console.error('Error deleting vulnerability assessment:', error);
      }
    },
    [dataInPage.length, table, fetchVulnerability]
  );

  const handleDeleteRows = useCallback(async () => {
    try {
      if (!endpoints.vulnerability_assessments?.delete) {
        console.error('Vulnerability assessments delete endpoint is undefined:', endpoints);
        toast.error('Configuration error: Missing vulnerability assessments delete endpoint.');
        return;
      }
      await Promise.all(
        table.selected.map((id) =>
          axiosInstance.delete(`${endpoints.vulnerability_assessments.delete}/${id}`)
        )
      );
      await fetchVulnerability();
      toast.success('Delete success!');
      table.onUpdatePageDeleteRows(dataInPage.length, dataFiltered.length);
    } catch (error) {
      toast.error('Failed to delete');
      console.error('Error deleting vulnerability assessments:', error);
    }
  }, [dataFiltered.length, dataInPage.length, table, fetchVulnerability]);

  const handleFilterStatus = useCallback(
    (event, newValue) => {
      table.onResetPage();
      updateFilters({ status: newValue });
    },
    [updateFilters, table]
  );

  const renderConfirmDialog = () => (
    <ConfirmDialog
      open={confirmDialog.value}
      onClose={confirmDialog.onFalse}
      title="Delete"
      content={
        <>
          Are you sure want to delete <strong> {table.selected.length} </strong> items?
        </>
      }
      action={
        <Button
          variant="contained"
          color="error"
          onClick={() => {
            handleDeleteRows();
            confirmDialog.onFalse();
          }}
        >
          Delete
        </Button>
      }
    />
  );

  return (
    <>
      <DashboardContent>
        <CustomBreadcrumbs
          heading="Vulnerability Assessments"
          links={[
            { name: 'Dashboard', href: paths.dashboard.root },
            { name: 'Create New Vulnerability Assessment', href: paths.dashboard.vulnerability.root },
            { name: 'Vulnerability Assessments' },
          ]}
          sx={{ mb: { xs: 3, md: 5 } }}
        />

        <Card>
          {importLoading && (
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: 'rgba(255, 255, 255, 0.8)',
                zIndex: 10,
              }}
            >
              <CircularProgress />
            </Box>
          )}

          <Tabs
            value={currentFilters.status}
            onChange={handleFilterStatus}
            sx={(theme) => ({
              px: 2.5,
              boxShadow: `inset 0 -2px 0 0 ${varAlpha(theme.vars.palette.grey['500Channel'], 0.08)}`,
            })}
          >
            {STATUS_OPTIONS.map((tab) => (
              <Tab
                key={tab.value}
                iconPosition="end"
                value={tab.value}
                label={tab.label}
                icon={
                  <Label
                    variant={
                      ((tab.value === 'all' || tab.value === currentFilters.status) && 'filled') ||
                      'soft'
                    }
                    color={
                      (tab.value === 'active' && 'success') ||
                      (tab.value === 'discharged' && 'warning') ||
                      'default'
                    }
                  >
                    {['active', 'discharged'].includes(tab.value)
                      ? tableData.filter((user) => user.programStatus.toLowerCase() === tab.value)
                          .length
                      : tableData.length}
                  </Label>
                }
              />
            ))}
          </Tabs>

          <OrderTableToolbar
            filters={filters}
            onResetPage={table.onResetPage}
            dateError={dateError}
            onImport={handleImport}
            tableData={tableData}
          />

          {canReset && (
            <JobFiltersResult
              filters={filters}
              totalResults={dataFiltered.length}
              onResetPage={table.onResetPage}
              sx={{ p: 2.5, pt: 0 }}
            />
          )}

          <Box sx={{ position: 'relative' }}>
            <TableSelectedAction
              dense={table.dense}
              numSelected={table.selected.length}
              rowCount={dataFiltered.length}
              onSelectAllRows={(checked) =>
                table.onSelectAllRows(
                  checked,
                  dataFiltered.map((row) => row.id)
                )
              }
              action={
                <Tooltip title="Delete">
                  <IconButton color="primary" onClick={confirmDialog.onTrue}>
                    <Iconify icon="solar:trash-bin-trash-bold" />
                  </IconButton>
                </Tooltip>
              }
            />

            <Scrollbar sx={{ minHeight: 444 }}>
              <Table size={table.dense ? 'small' : 'medium'} sx={{ minWidth: 960 }}>
                <TableHeadCustom
                  order={table.order}
                  orderBy={table.orderBy}
                  headCells={TABLE_HEAD}
                  rowCount={dataFiltered.length}
                  numSelected={table.selected.length}
                  onSort={table.onSort}
                  onSelectAllRows={(checked) =>
                    table.onSelectAllRows(
                      checked,
                      dataFiltered.map((row) => row.id)
                    )
                  }
                />

                <TableBody>
                  {loading ? (
                    <TableSkeleton />
                  ) : (
                    dataFiltered
                      .slice(
                        table.page * table.rowsPerPage,
                        table.page * table.rowsPerPage + table.rowsPerPage
                      )
                      .map((row) => (
                        <OrderTableRow
                          key={row.id}
                          row={row}
                          selected={table.selected.includes(row.id)}
                          onSelectRow={() => table.onSelectRow(row.id)}
                          onDeleteRow={() => handleDeleteRow(row.id)}
                          detailsHref={paths.dashboard.vulnerability.details(row.id)}
                          tableHead={TABLE_HEAD}
                        />
                      ))
                  )}

                  <TableEmptyRows
                    height={table.dense ? 56 : 56 + 20}
                    emptyRows={emptyRows(table.page, table.rowsPerPage, dataFiltered.length)}
                  />

                  <TableNoData notFound={notFound} />
                </TableBody>
              </Table>
            </Scrollbar>
          </Box>

          <TablePaginationCustom
            page={table.page}
            dense={table.dense}
            count={dataFiltered.length}
            rowsPerPage={table.rowsPerPage}
            onPageChange={table.onChangePage}
            onChangeDense={table.onChangeDense}
            onRowsPerPageChange={table.onChangeRowsPerPage}
          />
        </Card>
      </DashboardContent>

      {renderConfirmDialog()}
    </>
  );
}

// ----------------------------------------------------------------------

function applyFilter({ inputData, comparator, filters, dateError }) {
  const { status, name, startDate, endDate } = filters;

  const stabilizedThis = inputData.map((el, index) => [el, index]);

  stabilizedThis.sort((a, b) => {
    const order = comparator(a[0], b[0]);
    if (order !== 0) return order;
    return a[1] - b[1];
  });

  let filteredData = stabilizedThis.map((el) => el[0]);

  if (name) {
    filteredData = filteredData.filter((item) =>
      `${item.childFirstName} ${item.childLastName}`.toLowerCase().includes(name.toLowerCase())
    );
  }

  if (status !== 'all') {
    filteredData = filteredData.filter((item) => item.programStatus.toLowerCase() === status);
  }

  if (!dateError && startDate && endDate) {
    filteredData = filteredData.filter((item) =>
      fIsBetween(new Date(item.date), startDate, endDate)
    );
  }

  return filteredData;
}